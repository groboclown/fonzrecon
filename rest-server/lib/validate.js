'use strict';


// Accepts unicode.
const EMAIL_VALIDATION_RE = /^(([^<>()\[\]\.,;:\s@\"]+(\.[^<>()\[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i;


exports.errDetail = function(value, param, desc) {
  param = param || 'parameter';
  desc = desc || 'invalid value';
  return {
    msg: desc,
    param: param,
    value: value
  };
};


exports.error = function(value, param, desc) {
  return exports.errors([ exports.errDetail(value, param, desc) ]);
};


exports.errors = function(paramValues) {
  var err = new Error('ValidationError');
  err.details = paramValues;
  err.status = 400;
  return err;
};


function promiseReflect(p) {
  // Intentionally use the (then, catch) form.
  return p.then((v) => {
    return { v: v, status: 'resolved' };
  }, (e) => {
    if (!e.details) {
      // A real error.
      throw e;
    }
    return { e: e.details, status: 'rejected' };
  });
}
// Runs a list of validation promises (like Promise.all), but
// collects all the Error objects generated by each one.  If there
// were errors, they are collected into a single Error object and
// thrown together.
exports.allValidationPromises = function(validations) {
  return Promise
    .all(validations.map(promiseReflect))
    .then((results) => {
      var errors = results.filter(x => x.status === 'rejected');
      if (errors.length > 0) {
        var details = [];
        for (var i = 0; i < errors.length; i++) {
          details.concat(errors[i].e);
        }
        throw exports.errors(details);
      }
      return results.filter(x => x.status === 'resolved').map(x => x.v);
    });
};


exports.asValidateFunction = function(validateFunction, param, options) {
  if (typeof(validateFunction) !== 'function') {
    throw new TypeError('validateFunction must be a function');
  }
  return function(value) {
    var args = [value];
    args.concat(options);
    if (validateFunction.apply(null, args)) {
      return value;
    }
    throw exports.error(value, param);
  };
};


exports.asValidatePromiseFactory = function(validateFunction, param, options) {
  if (typeof(validateFunction) !== 'function') {
    throw new TypeError('validateFunction must be a function');
  }
  return function(value) {
    var args = [value];
    args.concat(options);
    if (validateFunction.apply(null, args)) {
      return Promise.resolve(value);
    }
    return Promise.reject(exports.error(value, param));
  };
};



exports.isEmailAddress = function(email) {
  if (!email || typeof(email) !== 'string') {
    return false;
  }
  return EMAIL_VALIDATION_RE.test(email);
};



exports.isBoolean = function(value) {
  return (value === true || value === false);
};



exports.isArray = function(value, minLength, maxLength) {
  minLength = minLength || 0;
  maxLength = maxLength || 100000000;
  return (!!value) && Array.isArray(value) &&
    value.length >= minLength && value.length <= maxLength;
};



exports.isArrayOf = function(value, elementValidation, minLength, maxLength) {
  if (!exports.isArray(value, minLength)) {
    return false;
  }
  for (var i = 0; i < value.length; i++) {
    if (!elementValidation(value[i])) {
      return false;
    }
  }
  return true;
};



exports.isURL = function(value) {
  // TODO
  return exports.isString(value, 6);
};



exports.isString = function(value, minLength, maxLength) {
  minLength = minLength || 0;
  maxLength = maxLength || 100000000;
  return (!!value) && typeof(value) === 'string' &&
    value.length >= minLength && value.length <= maxLength;
};



exports.isInSet = function(value, validValues) {
  return !!value && !!validValues.includes(value);
};



exports.yes = function(value) {
  return true;
};
